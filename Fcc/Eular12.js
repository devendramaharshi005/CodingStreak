{/*

Problem 12: Highly divisible triangular number

The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:
1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

Let us list the factors of the first seven triangle numbers:
1: 1
3: 1, 3
6: 1, 2, 3, 6
10: 1, 2, 5, 10
15: 1, 3, 5, 15
21: 1, 3, 7, 21
28: 1, 2, 4, 7, 14, 28

We can see that 28 is the first triangle number to have over five divisors.

What is the value of the first triangle number to have over n divisors?
Tests

Waiting: divisibleTriangleNumber(5) should return a number.
Waiting: divisibleTriangleNumber(5) should return 28.
Waiting: divisibleTriangleNumber(23) should return 630.
Waiting: divisibleTriangleNumber(167) should return 1385280.
Waiting: divisibleTriangleNumber(374) should return 17907120.
Waiting: divisibleTriangleNumber(500) should return 76576500.

*/}



// :( #INEFFICIENT : this approach is finding all the factors in O(n) time
//function findAllFactors(input_num){
//	let count =0;
//	for(let i=Math.floor(Math.sqrt(input_num)); i>=1; i--){
//		if(input_num%i === 0){
//			count++;
//		}
//	}
//	return count;

//}



// :) #EFFICIENT âˆ€ input_num <=500 : this approach is finding all the factors in O(sqare_root(n)) time
function findAllFactors(input_num){
    let count = 0;
    let sqrt = Math.sqrt(input_num);
    for(let i = 1; i <= sqrt; i++){
        if(input_num % i === 0){
            count += 2; // i and input_num/i are factors
			// for example if 1 is factor then 12/1 is also a factor
        }
    }
    // If input_num is a perfect square, we counted one factor twice
    if(sqrt * sqrt === input_num) {
        count--;
    }
    return count;
}


function divisibleTriangleNumber(n) {

  let triangleNum =1;
  let index = 2;

  while(findAllFactors(triangleNum) <= n){
	//next Triangle Number
	triangleNum+=(index)
	index++;
  }

  return triangleNum;
}

console.log("result",divisibleTriangleNumber(2000));