# CodingStreak

Here are the top 5 questions in each category: 

  

### 1. **Basic Operations** 

   - **Traversing:** 

     1. Find the sum of all elements in an array. 

     2. Count occurrences of a specific element in an array. 

     3. Find the maximum and minimum elements in an array. 

     4. Reverse an array in place. 

     5. Find the average of all elements in an array. 

   - **Searching:** 

     1. Find the index of a given element in an array. 

     2. Search for an element in a sorted array using Binary Search. 

     3. Find the first and last positions of an element in a sorted array. 

     4. Find the number of times a sorted array is rotated. 

     5. Search an element in a rotated sorted array. 

   - **Insertion/Deletion:** 

     1. Insert an element at a specific position. 

     2. Delete an element from a specific position. 

     3. Remove all occurrences of a given element in an array. 

     4. Merge two sorted arrays into one sorted array. 

     5. Rotate an array to the right by `k` steps. 

  

### 2. **Sorting** 

   - **Simple Sorting:** 

     1. Implement Bubble Sort. 

     2. Implement Selection Sort. 

     3. Implement Insertion Sort. 

     4. Sort an array of strings. 

     5. Sort an array of 0s, 1s, and 2s (Dutch National Flag problem). 

   - **Advanced Sorting:** 

     1. Implement Merge Sort. 

     2. Implement Quick Sort. 

     3. Find the `k`th smallest/largest element in an array. 

     4. Sort an array based on the frequency of elements. 

     5. Sort an array of integers using a custom comparator. 

  

### 3. **Two-Pointer Technique** 

   - **Pairing Elements:** 

     1. Find two numbers in an array that add up to a given sum. 

     2. Find all unique triplets in an array that sum up to zero. 

     3. Remove duplicates from a sorted array. 

     4. Find the closest pair to a given target in two sorted arrays. 

     5. Merge two sorted arrays without using extra space. 

   - **Partitioning:** 

     1. Move all zeroes to the end of the array. 

     2. Sort an array of 0s and 1s. 

     3. Partition an array around a pivot. 

     4. Rearrange an array so that all negative numbers appear before positive numbers. 

     5. Segregate even and odd numbers in an array. 

  

### 4. **Sliding Window** 

   - **Fixed Window:** 

     1. Find the maximum sum of `k` consecutive elements. 

     2. Find the minimum sum of `k` consecutive elements. 

     3. Find all subarrays of a fixed size with a sum greater than `X`. 

     4. Find the maximum number of vowels in a substring of length `k`. 

     5. Count the number of subarrays with exactly `k` distinct elements. 

   - **Dynamic Window:** 

     1. Find the smallest subarray with a sum greater than a given value. 

     2. Longest substring without repeating characters. 

     3. Longest subarray with a sum equal to `k`. 

     4. Find the longest substring with at most two distinct characters. 

     5. Maximum length of a subarray with sum less than or equal to `k`. 

  

### 5. **Divide and Conquer** 

   - **Recursion-Based:** 

     1. Find the maximum element in an array using a divide-and-conquer approach. 

     2. Implement the merge step in Merge Sort. 

     3. Find the majority element in an array. 

     4. Count the number of inversions in an array. 

     5. Find the closest pair of points in a 2D plane. 

----------------------------------------------------------------------------------------------------------- 

When dealing with questions on **Divide and Conquer** in coding interviews, certain keywords often appear that indicate the problem might require a divide-and-conquer approach. Here are some of the common keywords: 

  

### Keywords: 

1. **"Divide"** - Indicates the problem can be split into smaller parts. 

2. **"Conquer"** - Refers to solving each smaller part individually. 

3. **"Merge"** - Often related to combining the results of subproblems, as seen in merge sort. 

4. **"Recursion"** - The method of solving subproblems by calling the same function. 

5. **"Base Case"** - Refers to the simplest instance of the problem, which can be solved directly. 

6. **"Subproblem"** - Smaller instances of the problem that are easier to solve. 

7. **"Midpoint"** - Often used in binary search or to split the problem into two halves. 

8. **"Combine"** - Refers to the step where results from subproblems are aggregated to solve the original problem. 

9. **"Optimal Substructure"** - Indicates that the problem can be broken down into optimal solutions for subproblems. 

10. **"Binary Search"** - A specific type of divide-and-conquer approach. 

  

### Example Phrases: 

- "Divide the array into two halves" 

- "Solve the problem for each half" 

- "Combine the results of the two halves" 

- "Find the midpoint" 

- "Recursively solve for the left and right subarrays" 

- "Base case when the array size is 1" 

- "Merge the two sorted halves" 

- "Split the problem into smaller subproblems" 

  

These keywords can help identify when a divide-and-conquer approach is appropriate for a given coding problem. 

 

----------------------------------------------------------------------------------------------------------------- 

      

### 6. **Greedy Algorithms** 

   - **Optimization Problems:** 

     1. Find the minimum number of platforms required for a train station (overlapping intervals). 

     2. Find the maximum sum of non-adjacent elements. 

     3. Find the minimum number of jumps to reach the end of the array. 

     4. Find the largest number possible from the given digits. 

     5. Minimum number of coins/notes required to make a change of `n`. 

  

### 7. **Hashing** 

   - **Frequency Counting:** 

     1. Find the most frequent element in an array. 

     2. Group elements of the array with the same frequency. 

     3. Find the first non-repeating element in an array. 

     4. Find elements that appear more than `n/k` times in an array. 

     5. Count distinct elements in every window of size `k`. 

   - **Duplicate Detection:** 

     1. Check if an array contains duplicate elements. 

     2. Find the first repeating element in an array. 

     3. Find all pairs in an array that sum up to a given value. 

     4. Find the missing number in an array of consecutive numbers. 

     5. Check if two arrays are equal or not. 

  

### 8. **Dynamic Programming** 

   - **Subarray/Subsequence Problems:** 

     1. Find the longest increasing subsequence. 

     2. Find the maximum sum subarray (Kadane’s Algorithm). 

     3. Find the longest common subsequence. 

     4. Find the number of ways to reach the end of an array. 

     5. Partition an array into two subsets with equal sum. 

   - **Kadane’s Algorithm:** 

     1. Maximum sum subarray problem. 

     2. Find the maximum product subarray. 

     3. Find the maximum sum circular subarray. 

     4. Find the largest sum of non-adjacent elements. 

     5. Maximum sum of increasing subsequence. 

  

### 9. **Matrix-Based Arrays** 

   - **2D Array Traversal:** 

     1. Rotate a matrix by 90 degrees. 

     2. Find the largest sum rectangle in a 2D matrix. 

     3. Search for an element in a row-wise and column-wise sorted matrix. 

     4. Transpose a matrix. 

     5. Print a matrix in spiral order. 

   - **Searching in 2D Arrays:** 

     1. Find a specific element in a row-wise and column-wise sorted matrix. 

     2. Find the k-th smallest element in a sorted matrix. 

     3. Find the median of a matrix. 

     4. Count the number of islands in a binary matrix. 

     5. Find the largest rectangular sub-matrix with all 1s. 

  

### 10. **Miscellaneous** 

   - **Backtracking:** 

     1. Generate all subsets of an array. 

     2. Solve the N-Queens problem. 

     3. Generate all permutations of an array. 

     4. Solve the Sudoku problem. 

     5. Find all unique combinations that sum up to a target. 

   - **Bit Manipulation:** 

     1. Find the single non-repeating element in an array where every other element repeats twice. 

     2. Find two non-repeating elements in an array where every other element repeats twice. 

     3. Find the number of set bits in an integer. 

     4. Generate all possible subsets of an array using bit manipulation. 

     5. Check if a number is a power of two.d 

 

 

 

-------------------------------------------- arrays combined with other ------------------------------- 

When array questions are combined with other data structures, they can be classified based on the data structure used alongside the array. Here’s a classification: 

  

### 1. **Arrays + Hashing** 

   - **Problems Involving Frequency Counting:** 

     - Find the most frequent element in an array. 

     - Count distinct elements in an array. 

     - Find elements that appear more than `n/k` times in an array. 

   - **Problems Involving Hash Maps:** 

     - Two-sum problem: Find two numbers that add up to a given sum. 

     - Check if two arrays are equal or not. 

     - Find the longest subarray with a given sum. 

  

### 2. **Arrays + Stacks** 

   - **Monotonic Stack Problems:** 

     - Find the next greater element for each element in an array. 

     - Find the largest rectangular area in a histogram. 

     - Find the maximum of the minimums for every window size. 

   - **Balancing Problems:** 

     - Check for balanced parentheses using stacks and arrays. 

     - Evaluate a postfix expression using a stack. 

     - Simplify a directory path using stack and array. 

  

### 3. **Arrays + Queues** 

   - **Sliding Window Problems:** 

     - Find the maximum element in each sliding window of size `k`. 

     - First negative integer in every window of size `k`. 

     - Find the first non-repeating character in a stream of characters. 

   - **Circular Queue Problems:** 

     - Implement a circular queue using arrays. 

     - Design a data structure that supports the following operations: `insert`, `delete`, and `getRandom`. 

     - Implement the Deque data structure using arrays. 

  

### 4. **Arrays + Linked Lists** 

   - **Merging Problems:** 

     - Merge two sorted linked lists into a sorted array. 

     - Convert a sorted array to a balanced binary search tree (BST). 

     - Flatten a linked list that has a bottom pointer to another linked list. 

   - **Array Representation of Linked Lists:** 

     - Implement a linked list using arrays (array of pointers). 

     - Convert a linked list to an array and vice versa. 

     - Implement a LRU (Least Recently Used) cache using a linked list and array. 

  

### 5. **Arrays + Trees** 

   - **Traversal Problems:** 

     - Print all root-to-leaf paths in a binary tree stored in an array. 

     - Find the maximum path sum in a binary tree represented as an array. 

     - Convert a binary tree (stored as an array) to its mirror tree. 

   - **Heap Problems:** 

     - Build a max-heap/min-heap from an array. 

     - Find the k-th largest element in a stream using a binary heap. 

     - Merge k sorted arrays using a min-heap. 

  

### 6. **Arrays + Graphs** 

   - **Graph Representation:** 

     - Represent a graph using an adjacency matrix. 

     - Convert an adjacency list to an adjacency matrix and vice versa. 

     - Find the shortest path in a graph using an array-based priority queue. 

   - **Traversal Problems:** 

     - Find all nodes at distance `k` from a given node in a graph represented by an array. 

     - Detect a cycle in a directed graph using DFS and an auxiliary array. 

     - Implement Dijkstra’s algorithm using arrays and priority queues. 

  

### 7. **Arrays + Dynamic Programming** 

   - **Subarray/Subsequence Problems:** 

     - Find the longest increasing subsequence using dynamic programming and arrays. 

     - Find the maximum sum subarray using Kadane’s algorithm (DP approach). 

     - Count the number of ways to partition an array into two subsets with equal sum. 

   - **Matrix DP Problems:** 

     - Find the longest common subsequence in two arrays. 

     - Solve the coin change problem using dynamic programming with arrays. 

     - Find the number of distinct subsequences of a given sequence. 

  

### 8. **Arrays + Tries** 

   - **String Matching Problems:** 

     - Implement a Trie and use it for prefix-based search in an array of strings. 

     - Find the longest common prefix in an array of strings. 

     - Count the number of words with a given prefix in an array using a Trie. 

   - **Autocomplete Problems:** 

     - Implement an autocomplete system using a Trie and array. 

     - Find all words in an array that start with a given prefix using a Trie. 

     - Construct a Trie from an array of words and search for a given word. 

  

### 9. **Arrays + Bit Manipulation** 

   - **XOR Problems:** 

     - Find the single non-repeating element in an array where every other element repeats twice. 

     - Find two non-repeating elements in an array where every other element repeats twice. 

     - Find the missing number in an array of `n` elements. 

   - **Subset Problems:** 

     - Generate all subsets of an array using bit manipulation. 

     - Find the subset of an array that has the maximum XOR value. 

     - Count the number of subsets whose XOR is a given value. 

  

### 10. **Arrays + Backtracking** 

   - **Combination Problems:** 

     - Generate all possible permutations of an array. 

     - Find all unique subsets of an array that sum up to a target. 

     - Solve the N-Queens problem on a board represented by an array. 

   - **Sudoku and Puzzle Solving:** 

     - Solve a Sudoku puzzle using backtracking with arrays. 

     - Generate all valid IP addresses from a given string using backtracking and arrays. 

     - Find all possible palindrome partitions of a string using backtracking and arrays. 

  

These classifications combine arrays with other data structures to address a wide variety of coding challenges that might be encountered in interviews. 